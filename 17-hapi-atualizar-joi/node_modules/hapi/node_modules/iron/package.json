{
  "_args": [
    [
      "iron@https://registry.npmjs.org/iron/-/iron-5.0.6.tgz",
      "/home/thiago/Documentos/Dev/Courses/nodejs/17-hapi-atualizar-joi/node_modules/hapi"
    ]
  ],
  "_from": "iron@https://registry.npmjs.org/iron/-/iron-5.0.6.tgz",
  "_id": "iron@5.0.6",
  "_inCache": true,
  "_location": "/hapi/iron",
  "_phantomChildren": {},
  "_requested": {
    "name": "iron",
    "raw": "iron@https://registry.npmjs.org/iron/-/iron-5.0.6.tgz",
    "rawSpec": "https://registry.npmjs.org/iron/-/iron-5.0.6.tgz",
    "scope": null,
    "spec": "https://registry.npmjs.org/iron/-/iron-5.0.6.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/hapi/statehood"
  ],
  "_resolved": "https://registry.npmjs.org/iron/-/iron-5.0.6.tgz",
  "_shasum": "7121d4a6e3ac2f65e4d02971646fea1995434744",
  "_shrinkwrap": null,
  "_spec": "iron@https://registry.npmjs.org/iron/-/iron-5.0.6.tgz",
  "_where": "/home/thiago/Documentos/Dev/Courses/nodejs/17-hapi-atualizar-joi/node_modules/hapi",
  "bugs": {
    "url": "https://github.com/hueniverse/iron/issues"
  },
  "dependencies": {
    "b64": "4.x.x",
    "boom": "7.x.x",
    "cryptiles": "4.x.x",
    "hoek": "6.x.x"
  },
  "description": "Encapsulated tokens (encrypted and mac'ed objects)",
  "devDependencies": {
    "code": "5.x.x",
    "hapitoc": "1.x.x",
    "lab": "17.x.x"
  },
  "homepage": "https://github.com/hueniverse/iron#readme",
  "keywords": [
    "authentication",
    "data integrity",
    "encryption"
  ],
  "license": "BSD-3-Clause",
  "main": "lib/index.js",
  "name": "iron",
  "optionalDependencies": {},
  "readme": "# iron\n\n<img align=\"right\" src=\"https://raw.github.com/hueniverse/iron/master/images/logo.png\" /> **iron**\nis a cryptographic utility for sealing a JSON object using symmetric key encryption with message\nintegrity verification. Or in other words, it lets you encrypt an object, send it around (in\ncookies, authentication credentials, etc.), then receive it back and decrypt it. The algorithm\nensures that the message was not tampered with, and also provides a simple mechanism for password\nrotation.\n\nCurrent version: **5.x**\n\nNote: the wire protocol has not changed since 1.x (the version increments reflected a change in\nthe internal error format used by the module and by the node API as well as other node API changes).\n\n[![Build Status](https://secure.travis-ci.org/hueniverse/iron.png)](http://travis-ci.org/hueniverse/iron)\n\n\n## Table of Content\n\n- [**Introduction**](#introduction)\n<br /><br />\n- [Usage](#usage)\n<br /><br />\n- [API](#api)\n<br /><br />\n- [**Security Considerations**](#security-considerations)\n  - [Plaintext Storage of Credentials](#plaintext-storage-of-credentials)\n<br /><br />\n- [**Frequently Asked Questions**](#frequently-asked-questions)\n<br /><br />\n- [**Acknowledgements**](#acknowledgements)\n\n## Introduction\n\n**iron** provides methods for encrypting an object, generating a message authentication code (MAC),\nand serializing both into a cookie / URI / HTTP header friendly format. Sealed objects are useful\nin cases where state has to reside on other applications not under your control, without exposing\nthe details of this state to those application.\n\nFor example, sealed objects allow you to encrypt the permissions granted to the authenticated user,\nstore those permissions using a cookie, without worrying about someone modifying (or even knowing)\nwhat those permissions are. Any modification to the encrypted data will invalidate its integrity.\n\nThe seal process follows these general steps:\n\n- generate encryption salt `saltE`\n- derive an encryption key `keyE` using `saltE` and a password\n- generate an integrity salt `saltI`\n- derive an integrity (HMAC) key `keyI` using `saltI` and the password\n- generate a random [initialization vector](http://en.wikipedia.org/wiki/Initialization_vector) `iv`\n- encrypt the serialized object string using `keyE` and `iv`\n- mac the encrypted object along with `saltE` and `iv`\n- concatenate `saltE`, `saltI`, `iv`, and the encrypted object into a URI-friendly string\n\n## Usage\n\nTo seal an object:\n\n```javascript\nconst obj = {\n    a: 1,\n    b: 2,\n    c: [3, 4, 5],\n    d: {\n        e: 'f'\n    }\n};\n\nconst password = 'some_not_random_password_that_is_at_least_32_characters';\n\ntry {\n    const sealed = await Iron.seal(obj, password, Iron.defaults);\n} catch (err) {\n    console.log(err.message);\n}\n```\n\nThe result `sealed` object is a string which can be sent via cookies, URI query parameter, or an\nHTTP header attribute. To unseal the string:\n\n```javascript\ntry {\n    const unsealed = await Iron.unseal(sealed, password, Iron.defaults);\n} catch (err) {\n    console.log(err.message);\n}\n```\n\n## API\n\nSee the detailed [API Reference](https://github.com/hueniverse/iron/blob/master/API.md).\n\n## Security Considerations\n\nThe greatest sources of security risks are usually found not in **iron** but in the policies and\nprocedures surrounding its use. Implementers are strongly encouraged to assess how this module\naddresses their security requirements. This section includes an incomplete list of security\nconsiderations that must be reviewed and understood before using **iron**.\n\n### Plaintext Storage of Credentials\n\nThe **iron** password is only used to derive keys and is never sent or shared. However, in order to\ngenerate (and regenerate) the keys used to encrypt the object and compute the request MAC, the\nserver must have access to the password in plaintext form. This is in contrast, for example, to\nmodern operating systems, which store only a one-way hash of user credentials.\n\nIf an attacker were to gain access to the password - or worse, to the server's database of all such\npassword - he or she would be able to encrypt and decrypt any sealed object. Accordingly, it is\ncritical that servers protect these passwords from unauthorized access.\n\n## Frequently Asked Questions\n\n### Where is the protocol specification?\n\nIf you are looking for some prose explaining how all this works, there isn't any. **iron** is being\ndeveloped as an open source project instead of a standard. In other words, the [code](/lib) is the\nspecification. Not sure about something? Open an issue!\n\n### Is it done?\n\nYep.\n\n### How come the defaults must be manually passed and not automatically applied?\n\nBecause you should know what you are doing and explicitly set it. The options matter a lot to the\nsecurity properties of the implementation. While reasonable defaults are provided, you still need\nto explicitly state you want to use them.\n\n## Acknowledgements\n\nSpecial thanks to Adam Barth for his infinite patience, and always insightful feedback and advice.\n\nThe **iron** logo was based on original artwork created by [Chris Carrasco](http://chriscarrasco.com).\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/hueniverse/iron.git"
  },
  "scripts": {
    "test": "lab -a code -t 100 -L",
    "test-cov-html": "lab -a code -r html -o coverage.html",
    "toc": "hapitoc"
  },
  "version": "5.0.6"
}
